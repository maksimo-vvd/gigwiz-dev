{"version":3,"file":"index.production.js","sources":["../../../autocomplete-shared/dist/esm/flatten.js","../../../autocomplete-shared/dist/esm/generateAutocompleteId.js","../../../autocomplete-shared/dist/esm/getItemsCount.js","../../../autocomplete-shared/dist/esm/noop.js","../../src/utils/getNextActiveItemId.ts","../../src/utils/getActiveItem.ts","../../src/utils/isOrContainsNode.ts","../../src/getDefaultProps.ts","../../src/utils/getNormalizedSources.ts","../../src/resolve.ts","../../src/utils/mapToAlgoliaResponse.ts","../../src/onInput.ts","../../src/utils/createConcurrentSafePromise.ts","../../src/reshape.ts","../../src/getPropGetters.ts","../../src/onKeyDown.ts","../../src/getCompletion.ts","../../src/stateReducer.ts","../../src/createAutocomplete.ts","../../src/createStore.ts","../../src/getAutocompleteSetters.ts","../../src/version.ts"],"sourcesContent":["export function flatten(values) {\n  return values.reduce(function (a, b) {\n    return a.concat(b);\n  }, []);\n}","var autocompleteId = 0;\nexport function generateAutocompleteId() {\n  return \"autocomplete-\".concat(autocompleteId++);\n}","export function getItemsCount(state) {\n  if (state.collections.length === 0) {\n    return 0;\n  }\n\n  return state.collections.reduce(function (sum, collection) {\n    return sum + collection.items.length;\n  }, 0);\n}","export var noop = function noop() {};","/**\n * Returns the next active item ID from the current state.\n *\n * We allow circular keyboard navigation from the base index.\n * The base index can either be `null` (nothing is highlighted) or `0`\n * (the first item is highlighted).\n * The base index is allowed to get assigned `null` only if\n * `props.defaultActiveItemId` is `null`. This pattern allows to \"stop\"\n * by the actual query before navigating to other suggestions as seen on\n * Google or Amazon.\n *\n * @param moveAmount The offset to increment (or decrement) the last index\n * @param baseIndex The current index to compute the next index from\n * @param itemCount The number of items\n * @param defaultActiveItemId The default active index to fallback to\n */\nexport function getNextActiveItemId(\n  moveAmount: number,\n  baseIndex: number | null,\n  itemCount: number,\n  defaultActiveItemId: number | null\n): number | null {\n  if (!itemCount) {\n    return null;\n  }\n\n  if (\n    moveAmount < 0 &&\n    (baseIndex === null || (defaultActiveItemId !== null && baseIndex === 0))\n  ) {\n    return itemCount + moveAmount;\n  }\n\n  const numericIndex = (baseIndex === null ? -1 : baseIndex) + moveAmount;\n\n  if (numericIndex <= -1 || numericIndex >= itemCount) {\n    return defaultActiveItemId === null ? null : 0;\n  }\n\n  return numericIndex;\n}\n","import { AutocompleteCollection, AutocompleteState, BaseItem } from '../types';\n\n// We don't have access to the autocomplete source when we call `onKeyDown`\n// or `onClick` because those are native browser events.\n// However, we can get the source from the suggestion index.\nfunction getCollectionFromActiveItemId<TItem extends BaseItem>(\n  state: AutocompleteState<TItem>\n): AutocompleteCollection<TItem> | undefined {\n  // Given 3 sources with respectively 1, 2 and 3 suggestions: [1, 2, 3]\n  // We want to get the accumulated counts:\n  // [1, 1 + 2, 1 + 2 + 3] = [1, 3, 3 + 3] = [1, 3, 6]\n  const accumulatedCollectionsCount = state.collections\n    .map((collections) => collections.items.length)\n    .reduce<number[]>((acc, collectionsCount, index) => {\n      const previousValue = acc[index - 1] || 0;\n      const nextValue = previousValue + collectionsCount;\n\n      acc.push(nextValue);\n\n      return acc;\n    }, []);\n\n  // Based on the accumulated counts, we can infer the index of the suggestion.\n  const collectionIndex = accumulatedCollectionsCount.reduce((acc, current) => {\n    if (current <= state.activeItemId!) {\n      return acc + 1;\n    }\n\n    return acc;\n  }, 0);\n\n  return state.collections[collectionIndex];\n}\n\n/**\n * Gets the highlighted index relative to a suggestion object (not the absolute\n * highlighted index).\n *\n * Example:\n *  [['a', 'b'], ['c', 'd', 'e'], ['f']]\n *                      â†‘\n *         (absolute: 3, relative: 1)\n */\nfunction getRelativeActiveItemId<TItem extends BaseItem>({\n  state,\n  collection,\n}: {\n  state: AutocompleteState<TItem>;\n  collection: AutocompleteCollection<TItem>;\n}): number {\n  let isOffsetFound = false;\n  let counter = 0;\n  let previousItemsOffset = 0;\n\n  while (isOffsetFound === false) {\n    const currentCollection = state.collections[counter];\n\n    if (currentCollection === collection) {\n      isOffsetFound = true;\n      break;\n    }\n\n    previousItemsOffset += currentCollection.items.length;\n\n    counter++;\n  }\n\n  return state.activeItemId! - previousItemsOffset;\n}\n\nexport function getActiveItem<TItem extends BaseItem>(\n  state: AutocompleteState<TItem>\n) {\n  const collection = getCollectionFromActiveItemId(state);\n\n  if (!collection) {\n    return null;\n  }\n\n  const item = collection.items[getRelativeActiveItemId({ state, collection })];\n  const source = collection.source;\n  const itemInputValue = source.getItemInputValue({ item, state });\n  const itemUrl = source.getItemUrl({ item, state });\n\n  return {\n    item,\n    itemInputValue,\n    itemUrl,\n    source,\n  };\n}\n","export function isOrContainsNode(parent: Node, child: Node) {\n  return parent === child || parent.contains(child);\n}\n","import {\n  getItemsCount,\n  generateAutocompleteId,\n  flatten,\n} from '@algolia/autocomplete-shared';\n\nimport {\n  AutocompleteEnvironment,\n  AutocompleteOptions,\n  AutocompleteSubscribers,\n  BaseItem,\n  InternalAutocompleteOptions,\n} from './types';\nimport { getNormalizedSources } from './utils';\n\nexport function getDefaultProps<TItem extends BaseItem>(\n  props: AutocompleteOptions<TItem>,\n  pluginSubscribers: AutocompleteSubscribers<TItem>\n): InternalAutocompleteOptions<TItem> {\n  /* eslint-disable no-restricted-globals */\n  const environment: AutocompleteEnvironment = (typeof window !== 'undefined'\n    ? window\n    : {}) as typeof window;\n  /* eslint-enable no-restricted-globals */\n  const plugins = props.plugins || [];\n\n  return {\n    debug: false,\n    openOnFocus: false,\n    placeholder: '',\n    autoFocus: false,\n    defaultActiveItemId: null,\n    stallThreshold: 300,\n    environment,\n    shouldPanelOpen: ({ state }) => getItemsCount(state) > 0,\n    reshape: ({ sources }) => sources,\n    ...props,\n    // Since `generateAutocompleteId` triggers a side effect (it increments\n    // an internal counter), we don't want to execute it if unnecessary.\n    id: props.id ?? generateAutocompleteId(),\n    plugins,\n    // The following props need to be deeply defaulted.\n    initialState: {\n      activeItemId: null,\n      query: '',\n      completion: null,\n      collections: [],\n      isOpen: false,\n      status: 'idle',\n      context: {},\n      ...props.initialState,\n    },\n    onStateChange(params) {\n      props.onStateChange?.(params);\n      plugins.forEach((x) => x.onStateChange?.(params));\n    },\n    onSubmit(params) {\n      props.onSubmit?.(params);\n      plugins.forEach((x) => x.onSubmit?.(params));\n    },\n    onReset(params) {\n      props.onReset?.(params);\n      plugins.forEach((x) => x.onReset?.(params));\n    },\n    getSources(params) {\n      return Promise.all(\n        [...plugins.map((plugin) => plugin.getSources), props.getSources]\n          .filter(Boolean)\n          .map((getSources) => getNormalizedSources(getSources!, params))\n      )\n        .then((nested) => flatten(nested))\n        .then((sources) =>\n          sources.map((source) => ({\n            ...source,\n            onSelect(params) {\n              source.onSelect(params);\n              pluginSubscribers.forEach((x) => x.onSelect?.(params));\n            },\n            onActive(params) {\n              source.onActive(params);\n              pluginSubscribers.forEach((x) => x.onActive?.(params));\n            },\n          }))\n        );\n    },\n    navigator: {\n      navigate({ itemUrl }) {\n        environment.location.assign(itemUrl);\n      },\n      navigateNewTab({ itemUrl }) {\n        const windowReference = environment.open(itemUrl, '_blank', 'noopener');\n        windowReference?.focus();\n      },\n      navigateNewWindow({ itemUrl }) {\n        environment.open(itemUrl, '_blank', 'noopener');\n      },\n      ...props.navigator,\n    },\n  };\n}\n","import { invariant, decycle, noop } from '@algolia/autocomplete-shared';\n\nimport {\n  AutocompleteSource,\n  BaseItem,\n  GetSources,\n  GetSourcesParams,\n  InternalAutocompleteSource,\n  InternalGetSources,\n} from '../types';\n\nexport function getNormalizedSources<TItem extends BaseItem>(\n  getSources: GetSources<TItem>,\n  params: GetSourcesParams<TItem>\n): ReturnType<InternalGetSources<TItem>> {\n  const seenSourceIds: string[] = [];\n\n  return Promise.resolve(getSources(params)).then((sources) => {\n    invariant(\n      Array.isArray(sources),\n      () =>\n        `The \\`getSources\\` function must return an array of sources but returned type ${JSON.stringify(\n          typeof sources\n        )}:\\n\\n${JSON.stringify(decycle(sources), null, 2)}`\n    );\n\n    return Promise.all(\n      sources\n        // We allow `undefined` and `false` sources to allow users to use\n        // `Boolean(query) && source` (=> `false`).\n        // We need to remove these values at this point.\n        .filter((maybeSource: any): maybeSource is AutocompleteSource<TItem> =>\n          Boolean(maybeSource)\n        )\n        .map((source) => {\n          invariant(\n            typeof source.sourceId === 'string',\n            'A source must provide a `sourceId` string.'\n          );\n\n          if (seenSourceIds.includes(source.sourceId)) {\n            throw new Error(\n              `[Autocomplete] The \\`sourceId\\` ${JSON.stringify(\n                source.sourceId\n              )} is not unique.`\n            );\n          }\n\n          seenSourceIds.push(source.sourceId);\n\n          const normalizedSource: InternalAutocompleteSource<TItem> = {\n            getItemInputValue({ state }) {\n              return state.query;\n            },\n            getItemUrl() {\n              return undefined;\n            },\n            onSelect({ setIsOpen }) {\n              setIsOpen(false);\n            },\n            onActive: noop,\n            ...source,\n          };\n\n          return Promise.resolve(normalizedSource);\n        })\n    );\n  });\n}\n","import type {\n  Execute,\n  ExecuteResponse,\n  RequesterDescription,\n  TransformResponse,\n} from '@algolia/autocomplete-preset-algolia';\nimport { decycle, flatten, invariant } from '@algolia/autocomplete-shared';\nimport {\n  MultipleQueriesQuery,\n  SearchForFacetValuesResponse,\n  SearchResponse,\n} from '@algolia/client-search';\nimport type { SearchClient } from 'algoliasearch/lite';\n\nimport { BaseItem, InternalAutocompleteSource } from './types';\nimport { mapToAlgoliaResponse } from './utils';\n\nfunction isDescription<TItem extends BaseItem>(\n  item:\n    | RequestDescriptionPreResolved<TItem>\n    | RequestDescriptionPreResolvedCustom<TItem>\n    | PackedDescription<TItem>\n): item is RequestDescriptionPreResolved<TItem> {\n  return Boolean((item as RequestDescriptionPreResolved<TItem>).execute);\n}\n\nfunction isRequesterDescription<TItem extends BaseItem>(\n  description: TItem[] | TItem[][] | RequesterDescription<TItem>\n): description is RequesterDescription<TItem> {\n  return Boolean((description as RequesterDescription<TItem>)?.execute);\n}\n\ntype PackedDescription<TItem extends BaseItem> = {\n  searchClient: SearchClient;\n  execute: Execute<TItem>;\n  items: RequestDescriptionPreResolved<TItem>['requests'];\n};\n\ntype RequestDescriptionPreResolved<TItem extends BaseItem> = Pick<\n  RequesterDescription<TItem>,\n  'execute' | 'searchClient' | 'transformResponse'\n> & {\n  requests: Array<{\n    query: MultipleQueriesQuery;\n    sourceId: string;\n    transformResponse: TransformResponse<TItem>;\n  }>;\n};\n\ntype RequestDescriptionPreResolvedCustom<TItem extends BaseItem> = {\n  items: TItem[] | TItem[][];\n  sourceId: string;\n  transformResponse?: undefined;\n};\n\nexport function preResolve<TItem extends BaseItem>(\n  itemsOrDescription: TItem[] | TItem[][] | RequesterDescription<TItem>,\n  sourceId: string\n):\n  | RequestDescriptionPreResolved<TItem>\n  | RequestDescriptionPreResolvedCustom<TItem> {\n  if (isRequesterDescription<TItem>(itemsOrDescription)) {\n    return {\n      ...itemsOrDescription,\n      requests: itemsOrDescription.queries.map((query) => ({\n        query,\n        sourceId,\n        transformResponse: itemsOrDescription.transformResponse,\n      })),\n    };\n  }\n\n  return {\n    items: itemsOrDescription,\n    sourceId,\n  };\n}\n\nexport function resolve<TItem extends BaseItem>(\n  items: Array<\n    | RequestDescriptionPreResolved<TItem>\n    | RequestDescriptionPreResolvedCustom<TItem>\n  >\n) {\n  const packed = items.reduce<\n    Array<RequestDescriptionPreResolvedCustom<TItem> | PackedDescription<TItem>>\n  >((acc, current) => {\n    if (!isDescription(current)) {\n      acc.push(current);\n      return acc;\n    }\n\n    const { searchClient, execute, requests } = current;\n\n    const container = acc.find<PackedDescription<TItem>>(\n      (item): item is PackedDescription<TItem> => {\n        return (\n          isDescription(current) &&\n          isDescription(item) &&\n          item.searchClient === searchClient &&\n          item.execute === execute\n        );\n      }\n    );\n\n    if (container) {\n      container.items.push(...requests);\n    } else {\n      const request: PackedDescription<TItem> = {\n        execute,\n        items: requests,\n        searchClient,\n      };\n      acc.push(request);\n    }\n\n    return acc;\n  }, []);\n\n  const values = packed.map<\n    | Promise<RequestDescriptionPreResolvedCustom<TItem>>\n    | ReturnType<Execute<TItem>>\n  >((maybeDescription) => {\n    if (!isDescription<TItem>(maybeDescription)) {\n      return Promise.resolve(\n        maybeDescription as RequestDescriptionPreResolvedCustom<TItem>\n      );\n    }\n\n    const {\n      execute,\n      items,\n      searchClient,\n    } = maybeDescription as PackedDescription<TItem>;\n\n    return execute({\n      searchClient,\n      requests: items,\n    });\n  });\n\n  return Promise.all<\n    RequestDescriptionPreResolvedCustom<TItem> | ExecuteResponse<TItem>\n  >(values).then((responses) =>\n    flatten<\n      RequestDescriptionPreResolvedCustom<TItem> | ExecuteResponse<TItem>[0]\n    >(responses)\n  );\n}\n\nexport function postResolve<TItem extends BaseItem>(\n  responses: Array<\n    RequestDescriptionPreResolvedCustom<TItem> | ExecuteResponse<TItem>[0]\n  >,\n  sources: Array<InternalAutocompleteSource<TItem>>\n) {\n  return sources.map((source) => {\n    const matches = responses.filter(\n      (response) => response.sourceId === source.sourceId\n    );\n    const results = matches.map(({ items }) => items);\n    const transform = matches[0].transformResponse;\n    const items = transform\n      ? transform(\n          mapToAlgoliaResponse(\n            results as Array<\n              SearchForFacetValuesResponse | SearchResponse<TItem>\n            >\n          )\n        )\n      : results;\n\n    invariant(\n      Array.isArray(items),\n      () => `The \\`getItems\\` function from source \"${\n        source.sourceId\n      }\" must return an array of items but returned type ${JSON.stringify(\n        typeof items\n      )}:\\n\\n${JSON.stringify(decycle(items), null, 2)}.\n\nSee: https://www.algolia.com/doc/ui-libraries/autocomplete/core-concepts/sources/#param-getitems`\n    );\n\n    invariant(\n      (items as Array<typeof items>).every(Boolean),\n      `The \\`getItems\\` function from source \"${\n        source.sourceId\n      }\" must return an array of items but returned ${JSON.stringify(\n        undefined\n      )}.\n\nDid you forget to return items?\n\nSee: https://www.algolia.com/doc/ui-libraries/autocomplete/core-concepts/sources/#param-getitems`\n    );\n\n    return {\n      source,\n      items,\n    };\n  });\n}\n","import type {\n  SearchForFacetValuesResponse,\n  SearchResponse,\n} from '@algolia/client-search';\n\nexport function mapToAlgoliaResponse<THit>(\n  rawResults: Array<SearchResponse<THit> | SearchForFacetValuesResponse>\n) {\n  const results: Array<\n    SearchResponse<THit> | SearchForFacetValuesResponse\n  > = rawResults.map((result) => {\n    return {\n      ...result,\n      hits: (result as SearchResponse<THit>).hits?.map((hit) => {\n        // Bring support for the Insights plugin.\n        return {\n          ...hit,\n          __autocomplete_indexName: (result as SearchResponse<THit>).index,\n          __autocomplete_queryID: (result as SearchResponse<THit>).queryID,\n        };\n      }),\n    };\n  });\n\n  return {\n    results,\n    hits: results\n      .map((result) => (result as SearchResponse<THit>).hits)\n      .filter(Boolean),\n    facetHits: results\n      .map((result) =>\n        (result as SearchForFacetValuesResponse).facetHits?.map((facetHit) => {\n          // Bring support for the highlighting components.\n          return {\n            label: facetHit.value,\n            count: facetHit.count,\n            _highlightResult: {\n              label: {\n                value: facetHit.highlighted,\n              },\n            },\n          };\n        })\n      )\n      .filter(Boolean),\n  };\n}\n","import { reshape } from './reshape';\nimport { preResolve, resolve, postResolve } from './resolve';\nimport {\n  AutocompleteScopeApi,\n  AutocompleteState,\n  AutocompleteStore,\n  BaseItem,\n  InternalAutocompleteOptions,\n} from './types';\nimport { createConcurrentSafePromise, getActiveItem } from './utils';\n\nlet lastStalledId: number | null = null;\n\ninterface OnInputParams<TItem extends BaseItem>\n  extends AutocompleteScopeApi<TItem> {\n  event: any;\n  /**\n   * The next partial state to apply after the function is called.\n   *\n   * This is useful when we call `onInput` in a different scenario than an\n   * actual input. For example, we use `onInput` when we click on an item,\n   * but we want to close the panel in that case.\n   */\n  nextState?: Partial<AutocompleteState<TItem>>;\n  props: InternalAutocompleteOptions<TItem>;\n  query: string;\n  store: AutocompleteStore<TItem>;\n}\n\nconst runConcurrentSafePromise = createConcurrentSafePromise();\n\nexport function onInput<TItem extends BaseItem>({\n  event,\n  nextState = {},\n  props,\n  query,\n  refresh,\n  store,\n  ...setters\n}: OnInputParams<TItem>): Promise<void> {\n  if (lastStalledId) {\n    props.environment.clearTimeout(lastStalledId);\n  }\n\n  const {\n    setCollections,\n    setIsOpen,\n    setQuery,\n    setActiveItemId,\n    setStatus,\n  } = setters;\n\n  setQuery(query);\n  setActiveItemId(props.defaultActiveItemId);\n\n  if (!query && props.openOnFocus === false) {\n    const collections = store.getState().collections.map((collection) => ({\n      ...collection,\n      items: [],\n    }));\n\n    setStatus('idle');\n    setCollections(collections);\n    setIsOpen(\n      nextState.isOpen ?? props.shouldPanelOpen({ state: store.getState() })\n    );\n\n    // We make sure to update the latest resolved value of the tracked\n    // promises to keep late resolving promises from \"cancelling\" the state\n    // updates performed in this code path.\n    // We chain with a void promise to respect `onInput`'s expected return type.\n    return runConcurrentSafePromise(collections).then(() => Promise.resolve());\n  }\n\n  setStatus('loading');\n\n  lastStalledId = props.environment.setTimeout(() => {\n    setStatus('stalled');\n  }, props.stallThreshold);\n\n  // We track the entire promise chain triggered by `onInput` before mutating\n  // the Autocomplete state to make sure that any state manipulation is based on\n  // fresh data regardless of when promises individually resolve.\n  // We don't track nested promises and only rely on the full chain resolution,\n  // meaning we should only ever manipulate the state once this concurrent-safe\n  // promise is resolved.\n  return runConcurrentSafePromise(\n    props\n      .getSources({\n        query,\n        refresh,\n        state: store.getState(),\n        ...setters,\n      })\n      .then((sources) => {\n        return Promise.all(\n          sources.map((source) => {\n            return Promise.resolve(\n              source.getItems({\n                query,\n                refresh,\n                state: store.getState(),\n                ...setters,\n              })\n            ).then((itemsOrDescription) =>\n              preResolve<TItem>(itemsOrDescription, source.sourceId)\n            );\n          })\n        )\n          .then(resolve)\n          .then((responses) => postResolve(responses, sources))\n          .then((collections) =>\n            reshape({ collections, props, state: store.getState() })\n          );\n      })\n  )\n    .then((collections) => {\n      setStatus('idle');\n      setCollections(collections as any);\n      const isPanelOpen = props.shouldPanelOpen({\n        state: store.getState(),\n      });\n      setIsOpen(\n        nextState.isOpen ??\n          ((props.openOnFocus && !query && isPanelOpen) || isPanelOpen)\n      );\n\n      const highlightedItem = getActiveItem(store.getState());\n\n      if (store.getState().activeItemId !== null && highlightedItem) {\n        const { item, itemInputValue, itemUrl, source } = highlightedItem;\n\n        source.onActive({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n      }\n    })\n    .finally(() => {\n      if (lastStalledId) {\n        props.environment.clearTimeout(lastStalledId);\n      }\n    });\n}\n","import { MaybePromise } from '@algolia/autocomplete-shared';\n\n/**\n * Creates a runner that executes promises in a concurrent-safe way.\n *\n * This is useful to prevent older promises to resolve after a newer promise,\n * otherwise resulting in stale resolved values.\n */\nexport function createConcurrentSafePromise() {\n  let basePromiseId = -1;\n  let latestResolvedId = -1;\n  let latestResolvedValue: unknown = undefined;\n\n  return function runConcurrentSafePromise<TValue>(\n    promise: MaybePromise<TValue>\n  ) {\n    basePromiseId++;\n    const currentPromiseId = basePromiseId;\n\n    return Promise.resolve(promise).then((x) => {\n      // The promise might take too long to resolve and get outdated. This would\n      // result in resolving stale values.\n      // When this happens, we ignore the promise value and return the one\n      // coming from the latest resolved value.\n      //\n      // +----------------------------------+\n      // |        100ms                     |\n      // | run(1) +--->  R1                 |\n      // |        300ms                     |\n      // | run(2) +-------------> R2 (SKIP) |\n      // |        200ms                     |\n      // | run(3) +--------> R3             |\n      // +----------------------------------+\n      if (latestResolvedValue && currentPromiseId < latestResolvedId) {\n        return latestResolvedValue as TValue;\n      }\n\n      latestResolvedId = currentPromiseId;\n      latestResolvedValue = x;\n\n      return x;\n    });\n  };\n}\n","import { flatten } from '@algolia/autocomplete-shared';\n\nimport {\n  AutocompleteCollection,\n  AutocompleteReshapeSourcesBySourceId,\n  AutocompleteState,\n  BaseItem,\n  InternalAutocompleteOptions,\n} from './types';\n\ntype ReshapeParams<TItem extends BaseItem> = {\n  collections: Array<AutocompleteCollection<any>>;\n  props: InternalAutocompleteOptions<TItem>;\n  state: AutocompleteState<TItem>;\n};\n\nexport function reshape<TItem extends BaseItem>({\n  collections,\n  props,\n  state,\n}: ReshapeParams<TItem>) {\n  // Sources are grouped by `sourceId` to conveniently pick them via destructuring.\n  // Example: `const { recentSearchesPlugin } = sourcesBySourceId`\n  const sourcesBySourceId = collections.reduce<\n    AutocompleteReshapeSourcesBySourceId<TItem>\n  >(\n    (acc, collection) => ({\n      ...acc,\n      [collection.source.sourceId]: {\n        ...collection.source,\n        getItems() {\n          // We provide the resolved items from the collection to the `reshape` prop.\n          return flatten<any>(collection.items);\n        },\n      },\n    }),\n    {}\n  );\n\n  const reshapeSources = props.reshape({\n    sources: Object.values(sourcesBySourceId),\n    sourcesBySourceId,\n    state,\n  });\n\n  // We reconstruct the collections with the items modified by the `reshape` prop.\n  return flatten(reshapeSources)\n    .filter(Boolean)\n    .map((source) => {\n      return {\n        source,\n        items: source.getItems(),\n      };\n    });\n}\n","import { onInput } from './onInput';\nimport { onKeyDown } from './onKeyDown';\nimport {\n  AutocompleteScopeApi,\n  AutocompleteStore,\n  BaseItem,\n  GetEnvironmentProps,\n  GetFormProps,\n  GetInputProps,\n  GetItemProps,\n  GetLabelProps,\n  GetListProps,\n  GetPanelProps,\n  GetRootProps,\n  InternalAutocompleteOptions,\n} from './types';\nimport { getActiveItem, isOrContainsNode } from './utils';\n\ninterface GetPropGettersOptions<TItem extends BaseItem>\n  extends AutocompleteScopeApi<TItem> {\n  store: AutocompleteStore<TItem>;\n  props: InternalAutocompleteOptions<TItem>;\n}\n\nexport function getPropGetters<\n  TItem extends BaseItem,\n  TEvent,\n  TMouseEvent,\n  TKeyboardEvent\n>({ props, refresh, store, ...setters }: GetPropGettersOptions<TItem>) {\n  const getEnvironmentProps: GetEnvironmentProps = (providedProps) => {\n    const { inputElement, formElement, panelElement, ...rest } = providedProps;\n\n    return {\n      // On touch devices, we do not rely on the native `blur` event of the\n      // input to close the panel, but rather on a custom `touchstart` event\n      // outside of the autocomplete elements.\n      // This ensures a working experience on mobile because we blur the input\n      // on touch devices when the user starts scrolling (`touchmove`).\n      onTouchStart(event) {\n        if (\n          store.getState().isOpen === false ||\n          event.target === inputElement\n        ) {\n          return;\n        }\n\n        // @TODO: support cases where there are multiple Autocomplete instances.\n        // Right now, a second instance makes this computation return false.\n        const isTargetWithinAutocomplete = [formElement, panelElement].some(\n          (contextNode) => {\n            return (\n              isOrContainsNode(contextNode, event.target as Node) ||\n              isOrContainsNode(\n                contextNode,\n                props.environment.document.activeElement!\n              )\n            );\n          }\n        );\n\n        if (isTargetWithinAutocomplete === false) {\n          store.dispatch('blur', null);\n        }\n      },\n      // When scrolling on touch devices (mobiles, tablets, etc.), we want to\n      // mimic the native platform behavior where the input is blurred to\n      // hide the virtual keyboard. This gives more vertical space to\n      // discover all the suggestions showing up in the panel.\n      onTouchMove(event: TouchEvent) {\n        if (\n          store.getState().isOpen === false ||\n          inputElement !== props.environment.document.activeElement ||\n          event.target === inputElement\n        ) {\n          return;\n        }\n\n        inputElement.blur();\n      },\n      ...rest,\n    };\n  };\n\n  const getRootProps: GetRootProps = (rest) => {\n    return {\n      role: 'combobox',\n      'aria-expanded': store.getState().isOpen,\n      'aria-haspopup': 'listbox',\n      'aria-owns': store.getState().isOpen ? `${props.id}-list` : undefined,\n      'aria-labelledby': `${props.id}-label`,\n      ...rest,\n    };\n  };\n\n  const getFormProps: GetFormProps<TEvent> = (providedProps) => {\n    const { inputElement, ...rest } = providedProps;\n\n    return {\n      action: '',\n      noValidate: true,\n      role: 'search',\n      onSubmit: (event) => {\n        ((event as unknown) as Event).preventDefault();\n\n        props.onSubmit({\n          event,\n          refresh,\n          state: store.getState(),\n          ...setters,\n        });\n\n        store.dispatch('submit', null);\n        providedProps.inputElement?.blur();\n      },\n      onReset: (event) => {\n        ((event as unknown) as Event).preventDefault();\n\n        props.onReset({\n          event,\n          refresh,\n          state: store.getState(),\n          ...setters,\n        });\n\n        store.dispatch('reset', null);\n        providedProps.inputElement?.focus();\n      },\n      ...rest,\n    };\n  };\n\n  const getInputProps: GetInputProps<TEvent, TMouseEvent, TKeyboardEvent> = (\n    providedProps\n  ) => {\n    function onFocus(event: TEvent) {\n      // We want to trigger a query when `openOnFocus` is true\n      // because the panel should open with the current query.\n      if (props.openOnFocus || Boolean(store.getState().query)) {\n        onInput({\n          event,\n          props,\n          query: store.getState().completion || store.getState().query,\n          refresh,\n          store,\n          ...setters,\n        });\n      }\n\n      store.dispatch('focus', null);\n    }\n\n    const isTouchDevice = 'ontouchstart' in props.environment;\n    const { inputElement, maxLength = 512, ...rest } = providedProps || {};\n    const activeItem = getActiveItem(store.getState());\n\n    return {\n      'aria-autocomplete': 'both',\n      'aria-activedescendant':\n        store.getState().isOpen && store.getState().activeItemId !== null\n          ? `${props.id}-item-${store.getState().activeItemId}`\n          : undefined,\n      'aria-controls': store.getState().isOpen ? `${props.id}-list` : undefined,\n      'aria-labelledby': `${props.id}-label`,\n      value: store.getState().completion || store.getState().query,\n      id: `${props.id}-input`,\n      autoComplete: 'off',\n      autoCorrect: 'off',\n      autoCapitalize: 'off',\n      enterKeyHint: activeItem?.itemUrl ? 'go' : 'search',\n      spellCheck: 'false',\n      autoFocus: props.autoFocus,\n      placeholder: props.placeholder,\n      maxLength,\n      type: 'search',\n      onChange: (event) => {\n        onInput({\n          event,\n          props,\n          query: (((event as unknown) as Event)\n            .currentTarget as HTMLInputElement).value.slice(0, maxLength),\n          refresh,\n          store,\n          ...setters,\n        });\n      },\n      onKeyDown: (event) => {\n        onKeyDown({\n          event: (event as unknown) as KeyboardEvent,\n          props,\n          refresh,\n          store,\n          ...setters,\n        });\n      },\n      onFocus,\n      onBlur: () => {\n        // We do rely on the `blur` event on touch devices.\n        // See explanation in `onTouchStart`.\n        if (!isTouchDevice) {\n          store.dispatch('blur', null);\n        }\n      },\n      onClick: (event) => {\n        // When the panel is closed and you click on the input while\n        // the input is focused, the `onFocus` event is not triggered\n        // (default browser behavior).\n        // In an autocomplete context, it makes sense to open the panel in this\n        // case.\n        // We mimic this event by catching the `onClick` event which\n        // triggers the `onFocus` for the panel to open.\n        if (\n          providedProps.inputElement ===\n            props.environment.document.activeElement &&\n          !store.getState().isOpen\n        ) {\n          onFocus((event as unknown) as TEvent);\n        }\n      },\n      ...rest,\n    };\n  };\n\n  const getLabelProps: GetLabelProps = (rest) => {\n    return {\n      htmlFor: `${props.id}-input`,\n      id: `${props.id}-label`,\n      ...rest,\n    };\n  };\n\n  const getListProps: GetListProps = (rest) => {\n    return {\n      role: 'listbox',\n      'aria-labelledby': `${props.id}-label`,\n      id: `${props.id}-list`,\n      ...rest,\n    };\n  };\n\n  const getPanelProps: GetPanelProps<TMouseEvent> = (rest) => {\n    return {\n      onMouseDown(event) {\n        // Prevents the `activeElement` from being changed to the panel so\n        // that the blur event is not triggered, otherwise it closes the\n        // panel.\n        ((event as unknown) as MouseEvent).preventDefault();\n      },\n      onMouseLeave() {\n        store.dispatch('mouseleave', null);\n      },\n      ...rest,\n    };\n  };\n\n  const getItemProps: GetItemProps<any, TMouseEvent> = (providedProps) => {\n    const { item, source, ...rest } = providedProps;\n\n    return {\n      id: `${props.id}-item-${item.__autocomplete_id}`,\n      role: 'option',\n      'aria-selected': store.getState().activeItemId === item.__autocomplete_id,\n      onMouseMove(event) {\n        if (item.__autocomplete_id === store.getState().activeItemId) {\n          return;\n        }\n\n        store.dispatch('mousemove', item.__autocomplete_id);\n\n        const activeItem = getActiveItem(store.getState());\n\n        if (store.getState().activeItemId !== null && activeItem) {\n          const { item, itemInputValue, itemUrl, source } = activeItem;\n\n          source.onActive({\n            event,\n            item,\n            itemInputValue,\n            itemUrl,\n            refresh,\n            source,\n            state: store.getState(),\n            ...setters,\n          });\n        }\n      },\n      onMouseDown(event) {\n        // Prevents the `activeElement` from being changed to the item so it\n        // can remain with the current `activeElement`.\n        ((event as unknown) as MouseEvent).preventDefault();\n      },\n      onClick(event) {\n        const itemInputValue = source.getItemInputValue({\n          item,\n          state: store.getState(),\n        });\n        const itemUrl = source.getItemUrl({\n          item,\n          state: store.getState(),\n        });\n\n        // If `getItemUrl` is provided, it means that the suggestion\n        // is a link, not plain text that aims at updating the query.\n        // We can therefore skip the state change because it will update\n        // the `activeItemId`, resulting in a UI flash, especially\n        // noticeable on mobile.\n        const runPreCommand = itemUrl\n          ? Promise.resolve()\n          : onInput({\n              event,\n              nextState: { isOpen: false },\n              props,\n              query: itemInputValue,\n              refresh,\n              store,\n              ...setters,\n            });\n\n        runPreCommand.then(() => {\n          source.onSelect({\n            event,\n            item,\n            itemInputValue,\n            itemUrl,\n            refresh,\n            source,\n            state: store.getState(),\n            ...setters,\n          });\n        });\n      },\n      ...rest,\n    };\n  };\n\n  return {\n    getEnvironmentProps,\n    getRootProps,\n    getFormProps,\n    getLabelProps,\n    getInputProps,\n    getPanelProps,\n    getListProps,\n    getItemProps,\n  };\n}\n","import { onInput } from './onInput';\nimport {\n  ActionType,\n  AutocompleteScopeApi,\n  AutocompleteStore,\n  BaseItem,\n  InternalAutocompleteOptions,\n} from './types';\nimport { getActiveItem } from './utils';\n\ninterface OnKeyDownOptions<TItem extends BaseItem>\n  extends AutocompleteScopeApi<TItem> {\n  event: KeyboardEvent;\n  props: InternalAutocompleteOptions<TItem>;\n  store: AutocompleteStore<TItem>;\n}\n\nexport function onKeyDown<TItem extends BaseItem>({\n  event,\n  props,\n  refresh,\n  store,\n  ...setters\n}: OnKeyDownOptions<TItem>): void {\n  if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {\n    // eslint-disable-next-line no-inner-declarations\n    function triggerScrollIntoView() {\n      const nodeItem = props.environment.document.getElementById(\n        `${props.id}-item-${store.getState().activeItemId}`\n      );\n\n      if (nodeItem) {\n        if ((nodeItem as any).scrollIntoViewIfNeeded) {\n          (nodeItem as any).scrollIntoViewIfNeeded(false);\n        } else {\n          nodeItem.scrollIntoView(false);\n        }\n      }\n    }\n\n    // eslint-disable-next-line no-inner-declarations\n    function triggerOnActive() {\n      const highlightedItem = getActiveItem(store.getState());\n\n      if (store.getState().activeItemId !== null && highlightedItem) {\n        const { item, itemInputValue, itemUrl, source } = highlightedItem;\n\n        source.onActive({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n      }\n    }\n\n    // Default browser behavior changes the caret placement on ArrowUp and\n    // ArrowDown.\n    event.preventDefault();\n\n    // When re-opening the panel, we need to split the logic to keep the actions\n    // synchronized as `onInput` returns a promise.\n    if (\n      store.getState().isOpen === false &&\n      (props.openOnFocus || Boolean(store.getState().query))\n    ) {\n      onInput({\n        event,\n        props,\n        query: store.getState().query,\n        refresh,\n        store,\n        ...setters,\n      }).then(() => {\n        store.dispatch(event.key as ActionType, {\n          nextActiveItemId: props.defaultActiveItemId,\n        });\n\n        triggerOnActive();\n        // Since we rely on the DOM, we need to wait for all the micro tasks to\n        // finish (which include re-opening the panel) to make sure all the\n        // elements are available.\n        setTimeout(triggerScrollIntoView, 0);\n      });\n    } else {\n      store.dispatch(event.key, {});\n\n      triggerOnActive();\n      triggerScrollIntoView();\n    }\n  } else if (event.key === 'Escape') {\n    // This prevents the default browser behavior on `input[type=\"search\"]`\n    // from removing the query right away because we first want to close the\n    // panel.\n    event.preventDefault();\n\n    store.dispatch(event.key, null);\n  } else if (event.key === 'Enter') {\n    // No active item, so we let the browser handle the native `onSubmit` form\n    // event.\n    if (\n      store.getState().activeItemId === null ||\n      store\n        .getState()\n        .collections.every((collection) => collection.items.length === 0)\n    ) {\n      return;\n    }\n\n    // This prevents the `onSubmit` event to be sent because an item is\n    // highlighted.\n    event.preventDefault();\n\n    const { item, itemInputValue, itemUrl, source } = getActiveItem(\n      store.getState()\n    )!;\n\n    if (event.metaKey || event.ctrlKey) {\n      if (itemUrl !== undefined) {\n        source.onSelect({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n        props.navigator.navigateNewTab({\n          itemUrl,\n          item,\n          state: store.getState(),\n        });\n      }\n    } else if (event.shiftKey) {\n      if (itemUrl !== undefined) {\n        source.onSelect({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n        props.navigator.navigateNewWindow({\n          itemUrl,\n          item,\n          state: store.getState(),\n        });\n      }\n    } else if (event.altKey) {\n      // Keep native browser behavior\n    } else {\n      if (itemUrl !== undefined) {\n        source.onSelect({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n        props.navigator.navigate({\n          itemUrl,\n          item,\n          state: store.getState(),\n        });\n\n        return;\n      }\n\n      onInput({\n        event,\n        nextState: { isOpen: false },\n        props,\n        query: itemInputValue,\n        refresh,\n        store,\n        ...setters,\n      }).then(() => {\n        source.onSelect({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n      });\n    }\n  }\n}\n","import { AutocompleteState, BaseItem } from './types';\nimport { getActiveItem } from './utils';\n\ninterface GetCompletionProps<TItem extends BaseItem> {\n  state: AutocompleteState<TItem>;\n}\n\nexport function getCompletion<TItem extends BaseItem>({\n  state,\n}: GetCompletionProps<TItem>): string | null {\n  if (state.isOpen === false || state.activeItemId === null) {\n    return null;\n  }\n\n  return getActiveItem(state)?.itemInputValue || null;\n}\n","import { getItemsCount, invariant } from '@algolia/autocomplete-shared';\n\nimport { getCompletion } from './getCompletion';\nimport { Reducer } from './types';\nimport { getNextActiveItemId } from './utils';\n\nexport const stateReducer: Reducer = (state, action) => {\n  switch (action.type) {\n    case 'setActiveItemId': {\n      return {\n        ...state,\n        activeItemId: action.payload,\n      };\n    }\n\n    case 'setQuery': {\n      return {\n        ...state,\n        query: action.payload,\n        completion: null,\n      };\n    }\n\n    case 'setCollections': {\n      return {\n        ...state,\n        collections: action.payload,\n      };\n    }\n\n    case 'setIsOpen': {\n      return {\n        ...state,\n        isOpen: action.payload,\n      };\n    }\n\n    case 'setStatus': {\n      return {\n        ...state,\n        status: action.payload,\n      };\n    }\n\n    case 'setContext': {\n      return {\n        ...state,\n        context: {\n          ...state.context,\n          ...action.payload,\n        },\n      };\n    }\n\n    case 'ArrowDown': {\n      const nextState = {\n        ...state,\n        activeItemId: action.payload.hasOwnProperty('nextActiveItemId')\n          ? action.payload.nextActiveItemId\n          : getNextActiveItemId(\n              1,\n              state.activeItemId,\n              getItemsCount(state),\n              action.props.defaultActiveItemId\n            ),\n      };\n\n      return {\n        ...nextState,\n        completion: getCompletion({ state: nextState }),\n      };\n    }\n\n    case 'ArrowUp': {\n      const nextState = {\n        ...state,\n        activeItemId: getNextActiveItemId(\n          -1,\n          state.activeItemId,\n          getItemsCount(state),\n          action.props.defaultActiveItemId\n        ),\n      };\n\n      return {\n        ...nextState,\n        completion: getCompletion({ state: nextState }),\n      };\n    }\n\n    case 'Escape': {\n      if (state.isOpen) {\n        return {\n          ...state,\n          activeItemId: null,\n          isOpen: false,\n          completion: null,\n        };\n      }\n\n      return {\n        ...state,\n        activeItemId: null,\n        query: '',\n        status: 'idle',\n        collections: [],\n      };\n    }\n\n    case 'submit': {\n      return {\n        ...state,\n        activeItemId: null,\n        isOpen: false,\n        status: 'idle',\n      };\n    }\n\n    case 'reset': {\n      return {\n        ...state,\n        activeItemId:\n          // Since we open the panel on reset when openOnFocus=true\n          // we need to restore the highlighted index to the defaultActiveItemId. (DocSearch use-case)\n\n          // Since we close the panel when openOnFocus=false\n          // we lose track of the highlighted index. (Query-suggestions use-case)\n          action.props.openOnFocus === true\n            ? action.props.defaultActiveItemId\n            : null,\n        status: 'idle',\n        query: '',\n      };\n    }\n\n    case 'focus': {\n      return {\n        ...state,\n        activeItemId: action.props.defaultActiveItemId,\n        isOpen:\n          (action.props.openOnFocus || Boolean(state.query)) &&\n          action.props.shouldPanelOpen({ state }),\n      };\n    }\n\n    case 'blur': {\n      if (action.props.debug) {\n        return state;\n      }\n\n      return {\n        ...state,\n        isOpen: false,\n        activeItemId: null,\n      };\n    }\n\n    case 'mousemove': {\n      return {\n        ...state,\n        activeItemId: action.payload,\n      };\n    }\n\n    case 'mouseleave': {\n      return {\n        ...state,\n        activeItemId: action.props.defaultActiveItemId,\n      };\n    }\n\n    default:\n      invariant(\n        false,\n        `The reducer action ${JSON.stringify(action.type)} is not supported.`\n      );\n\n      return state;\n  }\n};\n","import { checkOptions } from './checkOptions';\nimport { createStore } from './createStore';\nimport { getAutocompleteSetters } from './getAutocompleteSetters';\nimport { getDefaultProps } from './getDefaultProps';\nimport { getPropGetters } from './getPropGetters';\nimport { onInput } from './onInput';\nimport { stateReducer } from './stateReducer';\nimport {\n  AutocompleteApi,\n  AutocompleteOptions,\n  BaseItem,\n  AutocompleteSubscribers,\n} from './types';\n\nexport function createAutocomplete<\n  TItem extends BaseItem,\n  TEvent = Event,\n  TMouseEvent = MouseEvent,\n  TKeyboardEvent = KeyboardEvent\n>(\n  options: AutocompleteOptions<TItem>\n): AutocompleteApi<TItem, TEvent, TMouseEvent, TKeyboardEvent> {\n  checkOptions(options);\n\n  const subscribers: AutocompleteSubscribers<TItem> = [];\n  const props = getDefaultProps(options, subscribers);\n  const store = createStore(stateReducer, props, onStoreStateChange);\n\n  const setters = getAutocompleteSetters({ store });\n  const propGetters = getPropGetters<\n    TItem,\n    TEvent,\n    TMouseEvent,\n    TKeyboardEvent\n  >({ props, refresh, store, ...setters });\n\n  function onStoreStateChange({ prevState, state }) {\n    props.onStateChange({ prevState, state, refresh, ...setters });\n  }\n\n  function refresh() {\n    return onInput({\n      event: new Event('input'),\n      nextState: { isOpen: store.getState().isOpen },\n      props,\n      query: store.getState().query,\n      refresh,\n      store,\n      ...setters,\n    });\n  }\n\n  props.plugins.forEach((plugin) =>\n    plugin.subscribe?.({\n      ...setters,\n      refresh,\n      onSelect(fn) {\n        subscribers.push({ onSelect: fn });\n      },\n      onActive(fn) {\n        subscribers.push({ onActive: fn });\n      },\n    })\n  );\n\n  return {\n    refresh,\n    ...propGetters,\n    ...setters,\n  };\n}\n","import {\n  AutocompleteState,\n  AutocompleteStore,\n  BaseItem,\n  InternalAutocompleteOptions,\n  Reducer,\n} from './types';\n\ntype OnStoreStateChange<TItem extends BaseItem> = ({\n  prevState,\n  state,\n}: {\n  prevState: AutocompleteState<TItem>;\n  state: AutocompleteState<TItem>;\n}) => void;\n\nexport function createStore<TItem extends BaseItem>(\n  reducer: Reducer,\n  props: InternalAutocompleteOptions<TItem>,\n  onStoreStateChange: OnStoreStateChange<TItem>\n): AutocompleteStore<TItem> {\n  let state = props.initialState;\n\n  return {\n    getState() {\n      return state;\n    },\n    dispatch(action, payload) {\n      const prevState = { ...state };\n      state = reducer(state, {\n        type: action,\n        props,\n        payload,\n      });\n\n      onStoreStateChange({ state, prevState });\n    },\n  };\n}\n","import { flatten } from '@algolia/autocomplete-shared';\n\nimport {\n  AutocompleteApi,\n  AutocompleteCollection,\n  AutocompleteStore,\n  BaseItem,\n} from './types';\n\ninterface GetAutocompleteSettersOptions<TItem extends BaseItem> {\n  store: AutocompleteStore<TItem>;\n}\n\nexport function getAutocompleteSetters<TItem extends BaseItem>({\n  store,\n}: GetAutocompleteSettersOptions<TItem>) {\n  const setActiveItemId: AutocompleteApi<TItem>['setActiveItemId'] = (\n    value\n  ) => {\n    store.dispatch('setActiveItemId', value);\n  };\n\n  const setQuery: AutocompleteApi<TItem>['setQuery'] = (value) => {\n    store.dispatch('setQuery', value);\n  };\n\n  const setCollections: AutocompleteApi<TItem>['setCollections'] = (\n    rawValue\n  ) => {\n    let baseItemId = 0;\n    const value = rawValue.map<AutocompleteCollection<TItem>>((collection) => ({\n      ...collection,\n      // We flatten the stored items to support calling `getAlgoliaResults`\n      // from the source itself.\n      items: flatten(collection.items as any).map((item: any) => ({\n        ...item,\n        __autocomplete_id: baseItemId++,\n      })),\n    }));\n\n    store.dispatch('setCollections', value);\n  };\n\n  const setIsOpen: AutocompleteApi<TItem>['setIsOpen'] = (value) => {\n    store.dispatch('setIsOpen', value);\n  };\n\n  const setStatus: AutocompleteApi<TItem>['setStatus'] = (value) => {\n    store.dispatch('setStatus', value);\n  };\n\n  const setContext: AutocompleteApi<TItem>['setContext'] = (value) => {\n    store.dispatch('setContext', value);\n  };\n\n  return {\n    setActiveItemId,\n    setQuery,\n    setCollections,\n    setIsOpen,\n    setStatus,\n    setContext,\n  };\n}\n","export const version = '1.4.1';\n"],"names":["flatten","values","reduce","a","b","concat","autocompleteId","getItemsCount","state","collections","length","sum","collection","items","noop","getNextActiveItemId","moveAmount","baseIndex","itemCount","defaultActiveItemId","numericIndex","getActiveItem","collectionIndex","map","acc","collectionsCount","index","nextValue","push","current","activeItemId","getCollectionFromActiveItemId","item","isOffsetFound","counter","previousItemsOffset","currentCollection","getRelativeActiveItemId","source","itemInputValue","getItemInputValue","itemUrl","getItemUrl","isOrContainsNode","parent","child","contains","getDefaultProps","props","pluginSubscribers","environment","window","plugins","debug","openOnFocus","placeholder","autoFocus","stallThreshold","shouldPanelOpen","reshape","sources","id","initialState","query","completion","isOpen","status","context","onStateChange","params","forEach","x","_x$onStateChange","onSubmit","_x$onSubmit","onReset","_x$onReset","getSources","Promise","all","plugin","filter","Boolean","seenSourceIds","resolve","then","maybeSource","sourceId","includes","Error","JSON","stringify","normalizedSource","onSelect","setIsOpen","onActive","getNormalizedSources","nested","_x$onSelect","_x$onActive","navigator","navigate","location","assign","navigateNewTab","windowReference","open","focus","navigateNewWindow","isDescription","execute","preResolve","itemsOrDescription","description","requests","queries","transformResponse","searchClient","container","find","request","maybeDescription","responses","postResolve","matches","response","results","transform","rawResults","result","hits","_hits","hit","__autocomplete_indexName","__autocomplete_queryID","queryID","facetHits","_facetHits","facetHit","label","value","count","_highlightResult","highlighted","mapToAlgoliaResponse","every","undefined","basePromiseId","latestResolvedId","latestResolvedValue","lastStalledId","runConcurrentSafePromise","promise","currentPromiseId","onInput","event","nextState","refresh","store","setters","clearTimeout","setCollections","setQuery","setActiveItemId","setStatus","getState","setTimeout","getItems","sourcesBySourceId","Object","isPanelOpen","highlightedItem","finally","getPropGetters","getEnvironmentProps","providedProps","inputElement","formElement","panelElement","onTouchStart","target","some","contextNode","document","activeElement","dispatch","onTouchMove","blur","getRootProps","rest","role","getFormProps","action","noValidate","preventDefault","getLabelProps","htmlFor","getInputProps","onFocus","isTouchDevice","maxLength","activeItem","autoComplete","autoCorrect","autoCapitalize","enterKeyHint","spellCheck","type","onChange","currentTarget","slice","onKeyDown","key","triggerScrollIntoView","nodeItem","getElementById","scrollIntoViewIfNeeded","scrollIntoView","triggerOnActive","nextActiveItemId","metaKey","ctrlKey","shiftKey","altKey","onBlur","onClick","getPanelProps","onMouseDown","onMouseLeave","getListProps","getItemProps","__autocomplete_id","onMouseMove","getCompletion","stateReducer","payload","hasOwnProperty","options","subscribers","reducer","onStoreStateChange","prevState","createStore","rawValue","baseItemId","setContext","getAutocompleteSetters","propGetters","Event","subscribe","_plugin$subscribe","fn"],"mappings":"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"}